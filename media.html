<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GitHub Media Player with Metadata Artist and Folder Sections</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f0f0f0;
    }
    h1 {
      text-align: center;
    }
    #player-container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 700px;
      margin: auto;
    }
    audio, video {
      width: 100%;
      margin-bottom: 10px;
    }
    button {
      margin: 5px 5px 5px 0;
      padding: 8px 15px;
      cursor: pointer;
    }
    .folder-section {
      background: white;
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
    }
    .folder-section h2 {
      margin-top: 0;
      border-bottom: 1px solid #ccc;
      padding-bottom: 5px;
    }
    ul.playlist {
      margin-top: 10px;
      list-style: none;
      padding-left: 0;
      max-height: 200px;
      overflow-y: auto;
    }
    ul.playlist li {
      padding: 8px;
      background: #eee;
      margin-bottom: 4px;
      border-radius: 4px;
      cursor: pointer;
    }
    ul.playlist li.playing {
      background: #cce5ff;
      font-weight: bold;
    }
    #file-input {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>GitHub Media Player with Metadata Artist and Folder Sections</h1>
  <div id="player-container">
    <input type="file" id="file-input" multiple accept="audio/*,video/*" /><br />
    <button id="loadFromGitHubBtn">Load Media from GitHub Repo</button>
    <button id="sortByArtistBtn">Sort by Artist</button>
    <audio id="audio-player" controls></audio>
    <video id="video-player" controls style="display:none;"></video>
  </div>
  <div id="folders-container"></div>

  <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>
  <script>
    const audioPlayer = document.getElementById('audio-player');
    const videoPlayer = document.getElementById('video-player');
    const fileInput = document.getElementById('file-input');
    const loadFromGitHubBtn = document.getElementById('loadFromGitHubBtn');
    const sortByArtistBtn = document.getElementById('sortByArtistBtn');
    const foldersContainer = document.getElementById('folders-container');

    let mediaFiles = [];
    let currentIndex = -1; // index in the flattened mediaFiles array
    let flattenedMedia = []; // flat list for play control
   
    function parseArtistFallback(filename) {
      const baseName = filename.replace(/\.[^/.]+$/, "");
      const parts = baseName.split(' - ');
      return parts.length > 1 ? parts[0].trim() : '';
    }

    function readArtistMetadata(fileOrUrl) {
      return new Promise((resolve) => {
        try {
          window.jsmediatags.read(fileOrUrl, {
            onSuccess: function(tag) {
              let artist = tag.tags.artist || '';
              resolve(artist.trim());
            },
            onError: function() {
              resolve('');
            }
          });
        } catch {
          resolve('');
        }
      });
    }

    async function createMediaFileObject(file) {
      let artist = '';
      if (file instanceof File || file instanceof Blob) {
        artist = await readArtistMetadata(file);
      } else {
        artist = parseArtistFallback(file.name || file);
      }
      if (!artist) {
        artist = parseArtistFallback(file.name || file);
      }
      return {
        name: file.name || file,
        url: file.url || file,
        type: (file.type && file.type.startsWith('video')) || /\.(mp4|webm)$/i.test(file.name || file) ? 'video' : 'audio',
        blob: file instanceof File || file instanceof Blob ? file : null,
        artist,
        path: file.path || file.name || file.url || ''
      };
    }

    // Group media by folder path (remove file name)
    function groupByFolder(files) {
      const groups = {};
      files.forEach(file => {
        // Extract folder path from full path (remove filename)
        let folder = file.path || '';
        if (folder.includes('/')) {
          folder = folder.substring(0, folder.lastIndexOf('/'));
        } else {
          folder = 'root'; // fallback
        }
        if (!groups[folder]) groups[folder] = [];
        groups[folder].push(file);
      });
      return groups;
    }

    function updateFoldersDisplay() {
      foldersContainer.innerHTML = '';
      const groups = groupByFolder(mediaFiles);
     
      // Flatten the grouped media for play control
      flattenedMedia = [];
      for (const folder in groups) {
        flattenedMedia = flattenedMedia.concat(groups[folder]);
      }

      for (const folder in groups) {
        const section = document.createElement('section');
        section.className = 'folder-section';

        const heading = document.createElement('h2');
        heading.textContent = folder === 'root' ? 'Root Folder' : folder;
        section.appendChild(heading);

        const ul = document.createElement('ul');
        ul.className = 'playlist';

        groups[folder].forEach(file => {
          const li = document.createElement('li');
          li.textContent = `${file.name}${file.artist ? ` (Artist: ${file.artist})` : ''}`;
          // Find index of this file in flattenedMedia to use for playing
          const flatIndex = flattenedMedia.indexOf(file);
          if (flatIndex === currentIndex) li.classList.add('playing');
          li.addEventListener('click', () => playMedia(flatIndex));
          ul.appendChild(li);
        });

        section.appendChild(ul);
        foldersContainer.appendChild(section);
      }
    }

    function playMedia(index) {
      if (index < 0 || index >= flattenedMedia.length) return;
      currentIndex = index;
      const file = flattenedMedia[index];

      if (file.type === 'video') {
        audioPlayer.style.display = 'none';
        videoPlayer.style.display = 'block';
        videoPlayer.src = file.url;
        videoPlayer.play();
        audioPlayer.pause();
        audioPlayer.src = '';
      } else {
        videoPlayer.style.display = 'none';
        audioPlayer.style.display = 'block';
        audioPlayer.src = file.url;
        audioPlayer.play();
        videoPlayer.pause();
        videoPlayer.src = '';
      }
      updateFoldersDisplay();
    }

    audioPlayer.addEventListener('ended', () => {
      if (currentIndex + 1 < flattenedMedia.length) playMedia(currentIndex + 1);
    });
    videoPlayer.addEventListener('ended', () => {
      if (currentIndex + 1 < flattenedMedia.length) playMedia(currentIndex + 1);
    });

    fileInput.addEventListener('change', async (event) => {
      const files = event.target.files;
      if (!files.length) return;
      mediaFiles = [];
      for (const f of files) {
        const mediaObj = await createMediaFileObject(f);
        mediaObj.url = URL.createObjectURL(f);
        // Since local files don't have path, put them in 'root'
        mediaObj.path = 'root/' + mediaObj.name;
        mediaFiles.push(mediaObj);
      }
      currentIndex = -1;
      updateFoldersDisplay();
      playMedia(0);
    });

    async function fetchGitHubMediaRecursive(owner, repo, path = 'media') {
      const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`GitHub API error: ${res.statusText}`);
        const items = await res.json();
        const validExts = /\.(mp3|flac|wav|ogg|m4a|mp4|webm)$/i;
        let mediaList = [];
        for (const item of items) {
          if (item.type === 'file' && validExts.test(item.name)) {
            mediaList.push({
              name: item.name,
              path: item.path,
              url: item.download_url,
              type: /\.(mp4|webm)$/i.test(item.name) ? 'video' : 'audio',
              blob: null,
              artist: parseArtistFallback(item.name),
            });
          } else if (item.type === 'dir') {
            const subfolderMedia = await fetchGitHubMediaRecursive(owner, repo, item.path);
            mediaList = mediaList.concat(subfolderMedia);
          }
        }
        return mediaList;
      } catch (err) {
        console.error(`Error fetching ${path}:`, err);
        return [];
      }
    }

    async function loadMediaFromGitHub() {
      const owner = 'mnnm666op';
      const repo = 'mnnm666op.github.io';
      const basePath = 'media';
      mediaFiles = await fetchGitHubMediaRecursive(owner, repo, basePath);
      if (mediaFiles.length === 0) {
        alert("No media files found in the GitHub repo folder.");
        return;
      }
      currentIndex = -1;
      updateFoldersDisplay();
      playMedia(0);
    }

    loadFromGitHubBtn.addEventListener('click', loadMediaFromGitHub);

    sortByArtistBtn.addEventListener('click', () => {
      // Sort each folder's files by artist name
      const grouped = groupByFolder(mediaFiles);
      for (const folder in grouped) {
        grouped[folder].sort((a, b) => {
          const artistA = a.artist.toLowerCase() || a.name.toLowerCase();
          const artistB = b.artist.toLowerCase() || b.name.toLowerCase();
          return artistA.localeCompare(artistB);
        });
      }
      // Flatten back to mediaFiles array in folder order
      mediaFiles = [];
      for (const folder in grouped) {
        mediaFiles = mediaFiles.concat(grouped[folder]);
      }
      currentIndex = -1;
      updateFoldersDisplay();
      if (mediaFiles.length > 0) playMedia(0);
    });
  </script>
</body>
</html>
